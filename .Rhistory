# plot the most used topics
topics.df <- convert(eo.dfm, to = 'data.frame')
topics.df <- data.frame(colSums(topics.df[,-1], dims = 1))
topics.df$topic <- rownames(topics.df)
colnames(topics.df) <- c('sum' , 'topic')
topics.df
# filter all topics for which we have more than x
topics.df <- topics.df[topics.df$sum >250, ]
topics.df$perc <- topics.df$sum / sum(topics.df$sum)
# bar chart
plot.topics <- ggplot(topics.df, aes(x = reorder(topic, perc), y= perc)) +
geom_bar(stat = "identity") +
coord_flip() +
theme_bw() +
labs(title = 'Classified Topics with Lexicoder',
y = 'percentage',
x = '',
subtitle = paste0('n = ', nrow(data)))
plot.topics
# compute the most relevant per document
topics.lexicoder <- convert(eo.dfm, to = 'data.frame')
length(unique(topics.lexicoder$doc_id))
highest_topic_df <- subset(topics.lexicoder, select = -c(doc_id) )
highest_topic <- colnames(highest_topic_df)[max.col(highest_topic_df,ties.method="first")]
# bind with original df
data<-cbind(data,highest_topic)
# filter topics for which we are certain, won't concern foreign policy
undesired_topics <- c('agriculture', 'education', 'forestry', 'social_welfare', 'housing')
data_sub <- filter(data, !highest_topic %in% undesired_topics)
eo.corpus <- corpus(data_sub,
docid_field =  "eo_number",
text_field = 'text')
head(summary(eo.corpus))
# create tokens
eo.tokens <- tokens(eo.corpus,
remove_punct = TRUE,
remove_numbers = TRUE,
remove_symbols = TRUE) %>%
tokens_remove(c(stopwords("english"),
undesirable_words))
# create labels
eo.label <- tokens_lookup(eo.tokens,
dictionary = data_dictionary_newsmap_en,
levels = 3) # level 3 stands for countries
# Document-feature matrix
dfmat_label <- dfm(eo.label, tolower = FALSE)
dfmat_feat <- dfm(eo.tokens, tolower = FALSE)
# select
dfmat_feat_select <- dfm_select(dfmat_feat, pattern = "^[A-Z][A-Za-z0-9]+",
valuetype = "regex", case_insensitive = FALSE) %>%
dfm_trim(min_termfreq = 10)
# train the newsmap textmodel
tmod_nm <- textmodel_newsmap(dfmat_feat_select, y = dfmat_label)
# check which coefficients are associated to the individual countries
coef <- coef(tmod_nm,n=15)[c("US","CN","IQ")]
df <- data.frame(unlist(coef))
df$word <- rownames(df)
rownames(df) <- NULL
df <- df %>% separate(word, c('ISO', 'Word'))
colnames(df) <- c('weight', 'ISO', 'word')
str(df)
plot.coef <- ggplot(df, aes(x = reorder(word, weight), y=weight, fill = ISO)) +
geom_col(show.legend = NULL)  +
facet_wrap(~ISO,
ncol = 3, nrow = 1,
scales = "free") +
theme(plot.subtitle=element_text(size=9, hjust=0.5, face="italic", color="black")) +
coord_flip() +
labs(title = 'Highest weighted words of Newsmap for given countries',
y = '',
x = '')
plot.coef
# predict and cluster country labels on our documents
pred_nm <- predict(tmod_nm)
count <-table(pred_nm)
count
# plot the newsmap
dat_country <- as.data.frame(count, stringsAsFactors = FALSE)
dat_country <- dat_country[order(-dat_country$Freq),]
dat_country$country <- countrycode(dat_country$pred_nm, origin = 'iso2c', destination = 'country.name')
colnames(dat_country) <- c("id", "frequency","country")
world_map <- map_data(map = "world")
world_map$region <- iso.alpha(world_map$region) # convert country name to ISO code
plot.map <- ggplot(dat_country, aes(map_id = id)) +
geom_map(aes(fill = frequency), map = world_map) +
expand_limits(x = world_map$long, y = world_map$lat) +
scale_fill_continuous(name = "Frequency") +
theme_void() +
coord_fixed() +
scale_fill_gradientn(colors=c("#56B1F7","green","yellow","orange","#ff0000"), values = scales::rescale(c(5, 25, 100, 200, 400))) +
labs(title = 'Frequency of countries (1950 -2021)',
subtitle = paste0('n = ', nrow(data)))
plot.map
# check Top 10 countries and convert ISO
top10 <- dat_country[1:10, ]
top10$country <- countrycode(top10$id, origin = 'iso2c', destination = 'country.name')
top10 <- top10[order(-top10$frequency),]
rownames(top10) <- NULL
# add country to dataframe
data$iso <- pred_nm
data$country <- countrycode(pred_nm, origin = 'iso2c', destination = 'country.name')
# check Top 10 countries and convert ISO
top10 <- dat_country[1:10, ]
top10$country <- countrycode(top10$id, origin = 'iso2c', destination = 'country.name')
top10 <- top10[order(-top10$frequency),]
rownames(top10) <- NULL
# add country to dataframe
data$iso <- pred_nm
View(data_sub)
# add country to dataframe
data_sub$iso <- pred_nm
data_sub$country <- countrycode(pred_nm, origin = 'iso2c', destination = 'country.name')
# get EOs only for top 10 countries
target <- top10$country
eo.top10 <- filter(data, country %in% target)
# plot frequency of top 10 countries
plot.top10 <- ggplot(top10, aes(x = frequency, y = reorder(country, frequency))) +
geom_bar(stat = 'identity') +
labs(title = 'Top 10 Frequency of countries (1950 -2021)',
y = '',
x = 'number of EOs',
subtitle = paste0('n = ', nrow(eo.top10))
) +
theme(plot.subtitle=element_text(size=9, hjust=0, face="italic", color="black"))
plot.top10
library(quanteda)
library("quanteda.textplots")
library(data.table)
library(tidytext) #text mining, unnesting
library(topicmodels) #the LDA algorithm
library(tidyr) #gather()
library(dplyr) #awesome tools
library(ggplot2) #visualization
library(kableExtra) #create attractive tables
library(knitr) #simple table generator
library(ggrepel) #text and label geoms for ggplot2
library(gridExtra)
library(formattable) #color tile and color bar in `kables`
library(tm) #text mining
library(circlize) #already loaded, but just being comprehensive
library(plotly) #interactive ggplot graphs
library(stm)
# set wd to where file is
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
data <- fread('./data/executive_orders_withcountry.csv')
#define some colors to use throughout
my_colors <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#D55E00", "#D65E00")
#customize ggplot2's default theme settings
#this tutorial doesn't actually pass any parameters, but you may use it again in future tutorials so it's nice to have the options
theme_custom <- function(aticks = element_blank(),
pgminor = element_blank(),
lt = element_blank(),
lp = "none")
{
theme(plot.title = element_text(hjust = 0.5), #center the title
axis.ticks = aticks, #set axis ticks to on or off
panel.grid.minor = pgminor, #turn on or off the minor grid lines
legend.title = lt, #turn on or off the legend title
legend.position = lp) #turn on or off the legend
}
# convert everything to lower case
data$text <- sapply(data$text, tolower)
# remove special characters
removeSpecialChars <- function(x) gsub("[^a-z ]", " ", x)
data$text <- sapply(data$text, removeSpecialChars)
# combine title and text
data$text <- with(data, paste0(title, text))
# examine first 300 characters of text
str(data[1, ]$text, nchar.max = 300)
str(data)
# manual exclusion of words
presidents <- tolower(unique(data$president))
presidents <- unlist(strsplit(presidents, " "))
undesirable_words <- c('about', 'search', 'president', 'united', 'states', 'of', 'america', 'american',
'executive', 'order', 'presidency', 'secretary', 'section', 'act')
undesirable_words <- append(undesirable_words, presidents)
# tidy up data to word dataframe
eo.words <- data %>%
unnest_tokens(word, text) %>%
anti_join(stop_words) %>%
filter(!word %in% undesirable_words) %>%
select(-c(document_type, title, iso))
nrow(eo.words) # we have over 1500k non-unique words!
#create the decade column
data <- data %>%
mutate(decade =
ifelse(data$year %in% 1950:1959, "1950s",
ifelse(data$year %in% 1960:1969, "1960s",
ifelse(data$year %in% 1970:1979, "1970s",
ifelse(data$year %in% 1980:1989, "1980s",
ifelse(data$year %in% 1990:1999, "1990s",
ifelse(data$year %in% 2000:2009, "2000s",
ifelse(data$year %in% 2010:2019, "2010s",
ifelse(data$year %in% 2020:2021, "2020s",
"NA")))))))))
# Plot amount of EOs over the decades
plot.decades <- data %>%
filter(decade != "NA") %>%
group_by(decade) %>%
summarise(number_of_eos = n()) %>%
ggplot() +
geom_bar(aes(x = decade, y = number_of_eos), stat = "identity")  +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
panel.grid.minor = element_blank()) +
labs(title = 'EO Count per decade',
y = 'EO counts',
x = '',
subtitle = paste0('n = ', nrow(data))) +
theme_bw()
plot.decades
# count words
full_word_count <- data %>%
unnest_tokens(word, text) %>% # split a column in to tokens
group_by(eo_number) %>%
summarise(num_words = n()) %>%
arrange(desc(num_words))
full_word_count$perc_words = full_word_count$num_words/sum(full_word_count$num_words)
full_word_count <- left_join(full_word_count, data, on = 'eo_number') %>%
select(-c(text, date, document_type, iso, decade))
# plot EOs with top word counts
plot.topwords <- full_word_count[1:10,] %>%
mutate(num_words = color_bar("lightblue")(num_words)) %>%
mutate(eo_number = color_tile("lightpink","lightpink")(eo_number)) %>%
kable("html", escape = FALSE, align = "c", caption = "EOs With Highest Word Count") %>%
kable_styling(bootstrap_options =
c("striped", "condensed", "bordered"),
full_width = FALSE)
plot.topwords
# plot the distribution of word counts
# we can see that it is heavily skewed
full_word_count %>%
ggplot() +
geom_histogram(aes(x = num_words)) +
ylab("EO Count") +
xlab("Word Count per EO") +
ggtitle("EOs Word Count Distribution") +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
panel.grid.minor.y = element_blank())
# let's manually look at the content of the EOs with highest word count
top1 <- full_word_count$eo_number[1]
top2 <- full_word_count$eo_number[2]
top3 <- full_word_count$eo_number[3]
str(data[data$eo_number==top1, 'text'], nchar.max = 1000)
str(data[data$eo_number==top2, 'text'], nchar.max = 1000)
str(data[data$eo_number==top3, 'text'], nchar.max = 1000)
# histogram with filtered
cut_off <- 5000
plot.wordcount.hist <- full_word_count %>%
filter(num_words<cut_off) %>%
ggplot() +
geom_histogram(aes(x = num_words)) +
ylab("EO Count") +
xlab("Word Count per EO") +
ggtitle("EOs Word Count Distribution") +
theme(plot.title = element_text(hjust = 0.5),
legend.title = element_blank(),
panel.grid.minor.y = element_blank())
plot.wordcount.hist
# count top n words
# this shows simply that we need to work with a TF-IDF to get the rare words
eo.words %>%
count(word, sort = TRUE) %>%
top_n(25) %>%
ungroup() %>%
mutate(word = reorder(word, n)) %>%
ggplot() +
geom_col(aes(word, n), fill = my_colors[4]) +
theme(legend.position = "none",
plot.title = element_text(hjust = 0.5),
panel.grid.major = element_blank()) +
xlab("") +
ylab("EO Count") +
ggtitle("Most Frequently Used Words in EOs (1950 - 2021)") +
coord_flip()
# TF-IDF, inverse document frequency
tfidf.decade <- eo.words %>%
left_join(data[, c('country', 'decade', 'eo_number')], on = 'eo_number') %>%
count(decade, word, sort = TRUE) %>%
bind_tf_idf(word, decade, n) %>%
arrange(desc(tf_idf)) %>%
group_by(decade) %>%
slice(seq_len(10)) %>%
ungroup() %>%
arrange(decade, tf_idf) %>%
mutate(row = row_number())
tfidf.eonumber <- eo.words %>%
left_join(data[, c('country', 'decade', 'eo_number')], on = 'eo_number') %>%
count(eo_number, word, sort = TRUE) %>%
bind_tf_idf(word, eo_number, n) %>%
arrange(desc(tf_idf)) %>%
group_by(eo_number) %>%
slice(seq_len(10)) %>%
ungroup() %>%
arrange(eo_number, tf_idf) %>%
mutate(row = row_number())
tfidf.onlychina <- eo.words %>%
left_join(data[, c('country', 'decade', 'eo_number')], on = 'eo_number') %>%
filter(country == 'China') %>%
count(decade, word, sort = TRUE) %>%
bind_tf_idf(word, decade, n) %>%
arrange(desc(tf_idf)) %>%
group_by(decade) %>%
slice(seq_len(10)) %>%
ungroup() %>%
arrange(decade, tf_idf) %>%
mutate(row = row_number())
plot <- function(df, title) {
ggplot(df, aes(x = row, y=tf_idf, fill = decade)) +
geom_col(show.legend = NULL) +
labs(x = NULL, y = "TF-IDF") +
labs(title = 'Important Words using TF-IDF',
subtitle = title) +
theme_custom() +
facet_wrap(~decade,
ncol = 3, nrow = 3,
scales = "free") +
scale_x_continuous(  # this handles replacement of row
breaks = df$row, # notice need to reuse data frame
labels = df$word) +
theme(plot.subtitle=element_text(size=9, hjust=0.5, face="italic", color="black")) +
coord_flip()
}
# plot the different types
plot(tfidf.decade, '(Grouped by decades)')
plot(tfidf.onlychina, '(Grouped by China)')
# Save  ----
#===================#
dir.create('./plots')
ggsave('plot_decades.png', path = './plots/', plot = plot.decades, device = 'png')
library(quanteda)
library("quanteda.textplots")
library(data.table)
library(tidytext) #text mining, unnesting
library(topicmodels) #the LDA algorithm
library(tidyr) #gather()
library(dplyr) #awesome tools
library(ggplot2) #visualization
library(kableExtra) #create attractive tables
library(knitr) #simple table generator
library(ggrepel) #text and label geoms for ggplot2
library(gridExtra)
library(formattable) #color tile and color bar in `kables`
library(tm) #text mining
library(circlize) #already loaded, but just being comprehensive
library(plotly) #interactive ggplot graphs
library(stm)
library(here)
library(readtext)
library(stringr)
library(newsmap)
library(sentimentr)
library(tidyr)
library(maps)
library(countrycode)
rm(list=ls())
# set wd to where file is
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
data <- fread('./data/executive_orders_cleaned.csv')
# 2 Topic Modeling wtih Lexicoder ----
#===================#
# # download dictionary
# download.file('http://www.snsoroka.com/wp-content/uploads/2020/08/LTDjun2013.zip',
#               destfile = './data/policy_agendas_english.zip')
# set up dictionary
lexicoder <- dictionary(file = './data/LTDjun2013/policy_agendas_english.lcd')
lengths(lexicoder)
eo.corpus <- corpus(data,
docid_field =  "eo_number",
text_field = 'text')
# remove our own words
undesirable_words <- c('president', 'united', 'states', 'of', 'america', 'american',
'executive', 'order', 'presidency', 'secretary', 'section', 'act')
presidents <- tolower(unique(data$president))
presidents <- unlist(strsplit(presidents, " "))
alphabet <- c('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'g', 'h', 'i', 'j', 'k' , 'l' , 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')
lists <- c('i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x')
month <- c("January", "February", "March", "April", "May", "June","July", "August", "September", "October", "November", "December")
day <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday","Sunday")
USA <- c("United","America","American","Americans","Washington")
start <- tolower(c('About Search', 'By the authority',  'vested in me as President by the Constitution', 'the laws of the United States of America', 'it is hereby ordered as follows', 'by virtue of the authority vested in me'))
end <-  tolower(c('The American Presidency Project', 'The American Presidency ProjectJohn Woolley and Gerhard PetersContact, Twitter Facebook, Copyright', 'The American Presidency ProjectTerms of Service'))
undesirable_words <- tolower(append(undesirable_words, c(presidents, alphabet, lists, month, day, USA, start, end)))
eo.dfm <- eo.corpus %>%
dfm(.,
tolower = TRUE,
remove = c(stopwords('english'), undesirable_words),
remove_punct = TRUE,
remove_numbers = TRUE,
remove_symbols = TRUE,
remove_url = TRUE,
remove_separators = TRUE,
include_docvars = TRUE,
dictionary = lexicoder)
head(eo.dfm)
# plot the most used topics
topics.df <- convert(eo.dfm, to = 'data.frame')
topics.df <- data.frame(colSums(topics.df[,-1], dims = 1))
topics.df$topic <- rownames(topics.df)
colnames(topics.df) <- c('sum' , 'topic')
topics.df
# filter all topics for which we have more than x
topics.df <- topics.df[topics.df$sum >250, ]
topics.df$perc <- topics.df$sum / sum(topics.df$sum)
# bar chart
plot.topics <- ggplot(topics.df, aes(x = reorder(topic, perc), y= perc)) +
geom_bar(stat = "identity") +
coord_flip() +
theme_bw() +
labs(title = 'Classified Topics with Lexicoder',
y = 'percentage',
x = '',
subtitle = paste0('n = ', nrow(data)))
plot.topics
# compute the most relevant per document
topics.lexicoder <- convert(eo.dfm, to = 'data.frame')
length(unique(topics.lexicoder$doc_id))
highest_topic_df <- subset(topics.lexicoder, select = -c(doc_id) )
highest_topic <- colnames(highest_topic_df)[max.col(highest_topic_df,ties.method="first")]
# bind with original df
data<-cbind(data,highest_topic)
# filter topics for which we are certain, won't concern foreign policy
undesired_topics <- c('agriculture', 'education', 'forestry', 'social_welfare', 'housing')
data_sub <- filter(data, !highest_topic %in% undesired_topics)
eo.corpus <- corpus(data_sub,
docid_field =  "eo_number",
text_field = 'text')
head(summary(eo.corpus))
# create tokens
eo.tokens <- tokens(eo.corpus,
remove_punct = TRUE,
remove_numbers = TRUE,
remove_symbols = TRUE) %>%
tokens_remove(c(stopwords("english"),
undesirable_words))
# create labels
eo.label <- tokens_lookup(eo.tokens,
dictionary = data_dictionary_newsmap_en,
levels = 3) # level 3 stands for countries
# Document-feature matrix
dfmat_label <- dfm(eo.label, tolower = FALSE)
dfmat_feat <- dfm(eo.tokens, tolower = FALSE)
# select
dfmat_feat_select <- dfm_select(dfmat_feat, pattern = "^[A-Z][A-Za-z0-9]+",
valuetype = "regex", case_insensitive = FALSE) %>%
dfm_trim(min_termfreq = 10)
# train the newsmap textmodel
tmod_nm <- textmodel_newsmap(dfmat_feat_select, y = dfmat_label)
# check which coefficients are associated to the individual countries
coef <- coef(tmod_nm,n=15)[c("US","CN","IQ")]
df <- data.frame(unlist(coef))
df$word <- rownames(df)
rownames(df) <- NULL
df <- df %>% separate(word, c('ISO', 'Word'))
colnames(df) <- c('weight', 'ISO', 'word')
str(df)
plot.coef <- ggplot(df, aes(x = reorder(word, weight), y=weight, fill = ISO)) +
geom_col(show.legend = NULL)  +
facet_wrap(~ISO,
ncol = 3, nrow = 1,
scales = "free") +
theme(plot.subtitle=element_text(size=9, hjust=0.5, face="italic", color="black")) +
coord_flip() +
labs(title = 'Highest weighted words of Newsmap for given countries',
y = '',
x = '')
plot.coef
# predict and cluster country labels on our documents
pred_nm <- predict(tmod_nm)
count <-table(pred_nm)
count
# plot the newsmap
dat_country <- as.data.frame(count, stringsAsFactors = FALSE)
dat_country <- dat_country[order(-dat_country$Freq),]
dat_country$country <- countrycode(dat_country$pred_nm, origin = 'iso2c', destination = 'country.name')
colnames(dat_country) <- c("id", "frequency","country")
world_map <- map_data(map = "world")
world_map$region <- iso.alpha(world_map$region) # convert country name to ISO code
plot.map <- ggplot(dat_country, aes(map_id = id)) +
geom_map(aes(fill = frequency), map = world_map) +
expand_limits(x = world_map$long, y = world_map$lat) +
scale_fill_continuous(name = "Frequency") +
theme_void() +
coord_fixed() +
scale_fill_gradientn(colors=c("#56B1F7","green","yellow","orange","#ff0000"), values = scales::rescale(c(5, 25, 100, 200, 400))) +
labs(title = 'Frequency of countries (1950 -2021)',
subtitle = paste0('n = ', nrow(data)))
plot.map
# check Top 10 countries and convert ISO
top10 <- dat_country[1:10, ]
top10$country <- countrycode(top10$id, origin = 'iso2c', destination = 'country.name')
top10 <- top10[order(-top10$frequency),]
rownames(top10) <- NULL
# add country to dataframe
data_sub$iso <- pred_nm
data_sub$country <- countrycode(pred_nm, origin = 'iso2c', destination = 'country.name')
View(data_sub)
# get a random sample of n=30 to manually check accuracy
set.seed(1234)
checking_accuracy <- sample_n(data_sub, 30)
View(checking_accuracy)
checking_accuracy$eo_number
df_eo_number <- as_data_frame(chekcing_accuracy$eo_number)
df_eo_number <- as_data_frame(checking_accuracy$eo_number)
View(df_eo_number)
install.packages("writexl")
library(writexl)
write_xlsx(checking_accuracy,'./data/executive_orders_cleaned.xlsx")
'./data/executive_orders_cleaned
write_xlsx(checking_accuracy,"C:\Users\Swen\Desktop\data_frame.xlsx")
write_xlsx(checking_accuracy,"C:\\Users\\Swen\\Desktop\\data_frame.xlsx")
